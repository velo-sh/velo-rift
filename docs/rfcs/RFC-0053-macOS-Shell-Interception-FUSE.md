# RFC-0053: macOS Shell Interception via FUSE-T

**Status**: Draft  
**Created**: 2026-02-02  
**Author**: Velo Rift Team

## Abstract

This RFC addresses the macOS SIP (System Integrity Protection) limitation that prevents shim-based interception of system binaries (`/bin/*`, `/usr/bin/*`). We propose FUSE-T as the ultimate solution and define a phased implementation strategy including a short-term wrapper virtualization approach.

---

## Problem Statement

macOS **System Integrity Protection (SIP)** prevents `DYLD_INSERT_LIBRARIES` from working on system binaries in `/bin/*` and `/usr/bin/*`. This means shell commands like `chmod`, `rm`, `mv`, `ln`, `touch`, `truncate` **bypass the shim completely**.

### Impact
- Build systems that shell out to these commands can mutate VFS files
- The shim's mutation perimeter is broken for shell-heavy workflows
- 5 of 6 core shell commands bypass protection (verified by `test_shell_mutation_suite.sh`)

### What Currently Works
- **Compiler I/O is protected**: `rustc`, `cargo` (via rustup) successfully load the shim
- **C/C++ binaries**: Custom-compiled programs are intercepted
- **Direct syscalls**: Any binary not SIP-protected works correctly

---

## Solution Comparison

| Approach | Isolation | Performance | Install Req. | Stability |
|----------|-----------|-------------|--------------|-----------|
| **FUSE-T** | â­â­â­ Complete | ~10-20% overhead | brew (admin) | â­â­â­ Best |
| **Wrapper Virtualization** | â­â­ Partial | None | None | â­â­ Bypassable |
| **Container** | â­â­â­ Complete | Heavy | Docker/Lima | â­â­â­ Best |

---

## Proposed Solution: FUSE-T Integration

### What is FUSE-T?

FUSE-T is a **kext-less** FUSE implementation for macOS. It runs an NFSv4 server in userspace, translating FUSE calls into NFS requests. This bypasses Apple's kernel extension restrictions.

### Architecture

```
Application accesses: /vrift/src/main.rs
     â†“
macOS NFS client sends request to localhost
     â†“
FUSE-T NFSv4 server receives request
     â†“
vrift-fuse daemon handles file operation
     â†“
Read from CAS or virtualized write (CoW)
```

### Installation Requirements

| Step | Privilege Required | Command |
|------|-------------------|---------|
| Install FUSE-T | **Admin (one-time)** | `brew install fuse-t` |
| Mount VFS | Regular user | `vrift mount /vrift` |
| Daily usage | Regular user | No special privileges |

**Key Points**:
- Installation is one-time, similar to installing Git or Docker
- After installation, **no root required** for daily usage
- **No SIP disable required**
- **No kernel extension (kext) required**

### Why FUSE-T is the Ultimate Solution

1. **Complete Transparency**: All programs (including `/bin/chmod`) go through FUSE layer
2. **Cannot Be Bypassed**: No "absolute path" bypass issue
3. **Industry Proven**: Bazel's Sandboxfs uses the same principle
4. **Acceptable Performance**: NFSv4 local communication adds ~10-20% overhead

### Implementation: `vrift-fuse` Crate

```
vrift-fuse/
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src/
    â”œâ”€â”€ lib.rs          // FUSE filesystem trait implementation
    â”œâ”€â”€ vnode_fs.rs     // VnodeEntry-based filesystem
    â”œâ”€â”€ cas_reader.rs   // Read blobs from CAS
    â””â”€â”€ cow_writer.rs   // Copy-on-Write for modifications
```

**Rust Dependency**: `fuser` crate (FUSE bindings for Rust)

---

## Short-Term Solution: Wrapper Virtualization

> **Important**: Wrappers don't "block" operationsâ€”they **convert shell commands to virtualized daemon IPC calls**.

### How It Works

```
User executes: mv /vrift/a.txt /vrift/b.txt
     â†“
Wrapper detects VFS path
     â†“
Calls daemon IPC: VirtualRename { from, to }
     â†“
Daemon updates manifest (path mapping)
     â†“
Returns success to user âœ“
```

### Wrapper Script Template (Virtualization)

```bash
#!/bin/bash
# ~/.vrift/bin/mv - VFS-aware mv (virtualized, not blocked!)
# Auto-generated by vrift init-wrappers

set -euo pipefail

VFS_PREFIX="${VRIFT_VFS_PREFIX:-/vrift}"

# Check if any argument is a VFS path
has_vfs_path=false
for arg in "$@"; do
    [[ "$arg" == -* ]] && continue
    [[ "$arg" == "$VFS_PREFIX"* ]] && has_vfs_path=true && break
done

if $has_vfs_path; then
    # Call daemon to perform virtualized rename
    exec vrift ipc virtual-rename "$@"
fi

# Non-VFS path, pass through to real command
exec /bin/mv "$@"
```

### Daemon IPC Extensions Required

```rust
// New VeloRequest variants for virtualized operations
enum VeloRequest {
    // Existing
    RegisterWorkspace { project_root: String },
    ManifestGet { path: String },
    
    // New: Virtualized mutation operations
    VirtualRename { from: String, to: String },
    VirtualChmod { path: String, mode: u32 },
    VirtualTouch { path: String, mtime: Option<u64> },
    VirtualUnlink { path: String },  // Soft delete (tombstone)
    VirtualLink { target: String, link: String },
}
```

### Behavior Matrix

| Command | Non-VFS Path | VFS Path | Implementation |
|---------|--------------|----------|----------------|
| `mv a b` | Pass-through `/bin/mv` | IPC: VirtualRename | Update manifest |
| `touch f` | Pass-through `/bin/touch` | IPC: VirtualTouch | Update mtime |
| `rm f` | Pass-through `/bin/rm` | IPC: VirtualUnlink | Add tombstone |
| `chmod 644 f` | Pass-through `/bin/chmod` | IPC: VirtualChmod | Update mode |

### Activation Methods

#### Method A: `vrift inception` (Recommended)

Inspired by the movie *Inception* (ç›—æ¢¦ç©ºé—´):

```bash
# Enter the "dream" (VFS environment)
eval "$(vrift inception)"
ğŸŒ€ Inception: Entering VFS layer...

# Run your build
cargo build

# Exit the "dream"
vrift wake
ğŸ’« Wake: Exiting VFS layer
```

#### Method B: Shell Hook (Auto-Inception)

```bash
# Add to ~/.zshrc or ~/.bashrc
eval "$(vrift hook zsh)"  # or bash/fish

# Now entering a VFS project auto-activates:
cd my-project/  # Auto inception if .vrift/ exists
cd ../          # Auto wake when leaving
```

### Limitations

| Limitation | Cause | Mitigation |
|------------|-------|------------|
| Absolute paths `/bin/chmod` | Bypasses PATH | Document, recommend FUSE-T |
| Scripts with hardcoded paths | Cannot intercept | Same as above |
| Only protects "good faith" programs | Malicious can bypass | Use FUSE-T for security |

---

## Platform Comparison

| Platform | Isolation Approach | Status |
|----------|-------------------|--------|
| **Linux** | Namespace + OverlayFS | âœ… Implemented |
| **macOS** | Shim (DYLD_INSERT) | âš ï¸ SIP-limited |
| **macOS** | FUSE-T | ğŸ”œ To be implemented |

### OverlayFS vs FUSE Relationship

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Linux                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  OverlayFS (kernel)                             â”‚
â”‚    â”œâ”€â”€ lower layer: CAS blobs (read-only)       â”‚
â”‚    â””â”€â”€ upper layer: /tmp/workspace (writable)   â”‚
â”‚  â†’ Uses kernel OverlayFS directly, best perf    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    macOS                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  No OverlayFS! Use FUSE-T to emulate:           â”‚
â”‚                                                 â”‚
â”‚  FUSE-T (userspace)                             â”‚
â”‚    â””â”€â”€ vrift-fuse daemon                        â”‚
â”‚          â”œâ”€â”€ read â†’ return blob from CAS        â”‚
â”‚          â””â”€â”€ write â†’ CoW to upper layer         â”‚
â”‚  â†’ Use FUSE to implement OverlayFS semantics    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Implementation Roadmap

| Phase | Approach | Rationale |
|-------|----------|-----------|
| **v1.0 (Short-term)** | Wrapper Virtualization | Simple, "good enough" protection |
| **v1.x (Medium-term)** | FUSE-T Integration | Completely transparent, cannot be bypassed |
| **v2.0 (Long-term)** | Container Mode | CI/security-critical scenarios |

---

## Action Items

1. [ ] Implement `VirtualRename`, `VirtualChmod` etc. in daemon
2. [ ] Implement `vrift inception` CLI command
3. [ ] Implement `vrift wake` CLI command
4. [ ] Implement `vrift hook <shell>` for auto-inception
5. [ ] Research FUSE-T Rust bindings (`fuser` crate)
6. [ ] Create `vrift-fuse` crate for FUSE-T integration
7. [ ] Document SIP limitation in USAGE.md
8. [ ] Add `vrift mount` CLI command for FUSE-T mode

---

## References

- [FUSE-T Official](https://www.fuse-t.org/)
- [fuser crate](https://crates.io/crates/fuser)
- [Bazel Sandboxfs](https://github.com/bazelbuild/sandboxfs)
- [test_shell_mutation_suite.sh](../tests/poc/test_shell_mutation_suite.sh)
